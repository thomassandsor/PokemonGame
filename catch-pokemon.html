<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catch Pokemon - QR Scanner</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
    html, body {
        height: 100vh;
        margin: 0;
        padding: 0;
        overflow-x: hidden;
        background: linear-gradient(135deg, #ff6b6b 0%, #4ecdc4 50%, #45b7d1 100%);
        font-family: 'Arial', sans-serif;
    }

    /* Pokemon-themed Scanner Frame */
    .pokemon-scanner-frame {
        position: relative;
        width: 90vw;
        max-width: 400px;
        margin: 20px auto;
        background: linear-gradient(145deg, #ffcc02, #3d7dca);
        padding: 8px;
        border-radius: 25px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        border: 4px solid #fff;
    }

    .pokemon-scanner-inner {
        background: #000;
        border-radius: 20px;
        padding: 15px;
        position: relative;
        overflow: hidden;
    }

    #qrVideo {
        width: 100%;
        height: 60vh;
        max-height: 400px;
        object-fit: cover;
        border-radius: 15px;
        display: block;
    }

    .pokemon-scanner-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 3px solid #ffcc02;
        border-radius: 15px;
        box-shadow: 0 0 0 4px rgba(255, 204, 2, 0.3);
        pointer-events: none;
        z-index: 10;
    }

    .pokemon-scanner-corners {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        pointer-events: none;
        z-index: 11;
    }

    .corner {
        position: absolute;
        width: 20px;
        height: 20px;
        border: 4px solid #ffcc02;
    }

    .corner.top-left {
        top: -2px;
        left: -2px;
        border-right: none;
        border-bottom: none;
        border-top-left-radius: 10px;
    }

    .corner.top-right {
        top: -2px;
        right: -2px;
        border-left: none;
        border-bottom: none;
        border-top-right-radius: 10px;
    }

    .corner.bottom-left {
        bottom: -2px;
        left: -2px;
        border-right: none;
        border-top: none;
        border-bottom-left-radius: 10px;
    }

    .corner.bottom-right {
        bottom: -2px;
        right: -2px;
        border-left: none;
        border-top: none;
        border-bottom-right-radius: 10px;
    }

    .pokemon-title {
        text-align: center;
        color: #fff;
        font-size: 1.8rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        margin-bottom: 20px;
    }

    .scan-instruction {
        text-align: center;
        color: #fff;
        font-size: 1.2rem;
        margin-top: 15px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
    }

    /* Fullscreen Modal Overlay */
    .modal-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.9);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        touch-action: none;
        overscroll-behavior: contain;
    }

    .modal-content {
        width: 90vw;
        max-width: 500px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 20px;
    }

    .pokemon-encounter {
        background: linear-gradient(145deg, #667eea 0%, #764ba2 100%);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        border: 3px solid #fff;
    }

    .pokemon-sprite-large {
        width: 60vw;
        max-width: 250px;
        height: auto;
        margin-bottom: 20px;
        filter: drop-shadow(0 5px 15px rgba(0, 0, 0, 0.3));
    }

    .pokemon-name {
        color: #fff;
        font-size: 2rem;
        font-weight: bold;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        margin-bottom: 20px;
    }

    .modal-actions {
        display: flex;
        gap: 20px;
        justify-content: center;
        margin-top: 20px;
    }

    .btn-pokemon {
        font-size: 1.3rem;
        padding: 12px 30px;
        border-radius: 25px;
        border: none;
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    .btn-pokemon.catch {
        background: linear-gradient(145deg, #ff6b6b, #ee5a52);
        color: white;
    }

    .btn-pokemon.catch:hover {
        transform: translateY(-2px);
        box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
    }

    .btn-pokemon.run {
        background: linear-gradient(145deg, #feca57, #ff9ff3);
        color: #333;
    }

    .btn-pokemon.run:hover {
        transform: translateY(-2px);
        box-shadow: 0 7px 20px rgba(0, 0, 0, 0.3);
    }

    /* Throw Animation Container */
    .throw-container {
        text-align: center;
        color: #fff;
    }

    .throw-instructions {
        font-size: 1.4rem;
        font-weight: bold;
        margin-bottom: 30px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
    }

    .catch-zone {
        margin: 30px 0;
        position: relative;
    }

    .pokeball {
        width: 80px;
        height: 80px;
        margin: 20px auto;
        display: block;
        cursor: pointer;
        transition: transform 0.3s ease;
    }

    .pokeball:hover {
        transform: scale(1.1);
    }

    /* Animation for scanning pulse effect */
    @keyframes scanPulse {
        0% { box-shadow: 0 0 0 0 rgba(255, 204, 2, 0.7); }
        70% { box-shadow: 0 0 0 20px rgba(255, 204, 2, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 204, 2, 0); }
    }

    .pokemon-scanner-overlay.scanning {
        animation: scanPulse 2s infinite;
    }

    /* Hidden by default */
    .hidden {
        display: none !important;
    }

    /* Pokeball count display */
    .pokeball-count {
        background: rgba(255, 255, 255, 0.2);
        color: #fff;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 1rem;
        font-weight: bold;
        margin-bottom: 15px;
        text-align: center;
    }

    .pokeball-count.empty {
        background: rgba(255, 107, 107, 0.3);
        color: #ff6b6b;
    }

    /* No pokeballs message */
    .no-pokeballs-message {
        background: rgba(255, 107, 107, 0.2);
        border: 2px solid #ff6b6b;
        color: #fff;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
    }
    </style>
</head>
<body>
    <!-- Pokemon QR Scanner -->
    <div id="scannerContainer" class="container">
        <div class="pokemon-title">üîç Pok√©mon Scanner</div>
        
        <div class="pokemon-scanner-frame">
            <div class="pokemon-scanner-inner">
                <video id="qrVideo" playsinline autoplay></video>
                <div class="pokemon-scanner-overlay scanning"></div>
                <div class="pokemon-scanner-corners">
                    <div class="corner top-left"></div>
                    <div class="corner top-right"></div>
                    <div class="corner bottom-left"></div>
                    <div class="corner bottom-right"></div>
                </div>
            </div>
        </div>
        
        <div class="scan-instruction">
            Point your camera at a Pok√©mon QR code
        </div>
        
        <div id="videoDebugInfo" style="color:#fff; text-align:center; margin-top:15px; font-size:0.9rem;"></div>
    </div>

    <!-- Pokemon Encounter Modal -->
    <div id="encounterModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="pokemon-encounter">
                <img id="encounterPokemonImage" class="pokemon-sprite-large" src="" alt="Pokemon">
                <div id="encounterPokemonName" class="pokemon-name">Loading...</div>
                
                <!-- Pokeball Count Display -->
                <div id="pokeballCountDisplay" class="pokeball-count">
                    ‚öæ Pok√©balls: <span id="pokeballCount">0</span>
                </div>
                
                <!-- Default Actions (when pokeballs available) -->
                <div id="defaultActions" class="modal-actions">
                    <button class="btn-pokemon catch" onclick="startThrowAnimation()">
                        ‚öæ Catch!
                    </button>
                    <button class="btn-pokemon run" onclick="runAway()">
                        üèÉ Run Away
                    </button>
                </div>

                <!-- No Pokeballs Message -->
                <div id="noPokeballs" class="no-pokeballs-message hidden">
                    ‚ùå No more Pok√©balls!<br>
                    <small>Play a minigame to earn them</small>
                </div>

                <!-- No Pokeballs Actions -->
                <div id="noPokeballActions" class="modal-actions hidden">
                    <button class="btn-pokemon catch" onclick="MinigameLibrary.showMinigameSelection()">
                        üéÆ Choose Minigame
                    </button>
                    <button class="btn-pokemon run" onclick="runAway()">
                        üèÉ Run Away
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pokeball Throw Animation -->
    <div id="throwModal" class="modal-overlay hidden">
        <div class="modal-content">
            <div class="throw-container">
                <div class="throw-instructions">Swipe up to throw the Pok√©ball!</div>
                <div class="catch-zone">
                    <img id="throwPokemonSprite" class="pokemon-sprite-large" src="" alt="Target Pokemon">
                </div>
                <img id="pokeball" class="pokeball" src="assets/pokeball.svg" alt="Pokeball">
            </div>
        </div>
    </div>

    <!-- Include Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Include jsQR library for QR code scanning -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    
    <!-- Include Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Include Auth Service -->
    <script src="auth.js"></script>
    
    <!-- Include Catch Pokemon Service -->
    <script src="catch-pokemon-service.js"></script>
    
    <!-- Include Minigame Library -->
    <script src="minigame-library.js"></script>
    
    <!-- Include Pokeball Throw Logic -->
    <script src="throw-pokeball.js"></script>
    
    <script>
        // Global variables
        let currentPokemonData = null;
        let qrScanner = null;

        // UI State Management
        const UI_STATES = {
            SCANNER: 'scanner',
            ENCOUNTER: 'encounter', 
            THROW: 'throw'
        };

        let currentState = UI_STATES.SCANNER;

        // Show only the specified UI state
        function showUIState(state) {
            currentState = state;
            
            // Hide all containers
            document.getElementById('scannerContainer').classList.add('hidden');
            document.getElementById('encounterModal').classList.add('hidden');
            document.getElementById('throwModal').classList.add('hidden');
            
            // Show the requested state
            switch(state) {
                case UI_STATES.SCANNER:
                    document.getElementById('scannerContainer').classList.remove('hidden');
                    // Restart scanner if it exists
                    if (qrScanner && !qrScanner.scanning) {
                        qrScanner.startScanning();
                    }
                    break;
                    
                case UI_STATES.ENCOUNTER:
                    document.getElementById('encounterModal').classList.remove('hidden');
                    break;
                    
                case UI_STATES.THROW:
                    document.getElementById('throwModal').classList.remove('hidden');
                    break;
            }
        }

        // Show loading spinner with rotating pokeball
        function showLoadingSpinner(message = 'Loading...') {
            // Remove any existing spinner first
            hideLoadingSpinner();
            
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'globalLoadingOverlay';
            loadingOverlay.className = 'modal-overlay';
            loadingOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;
            loadingOverlay.innerHTML = `
                <style>
                    @keyframes rotatePokeball {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                    .rotating-pokeball-svg {
                        width: 80px;
                        height: 80px;
                        animation: rotatePokeball 1.5s linear infinite;
                        margin-bottom: 20px;
                        filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
                    }
                </style>
                <div style="text-align: center; color: white; padding: 40px;">
                    <svg class="rotating-pokeball-svg" width="80" height="80" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="60" cy="60" r="55" stroke="#222" stroke-width="5" fill="#fff"/>
                        <path d="M5 60a55 55 0 0 1 110 0" fill="#e53935" stroke="#222" stroke-width="5"/>
                        <circle cx="60" cy="60" r="20" stroke="#222" stroke-width="5" fill="#fff"/>
                        <circle cx="60" cy="60" r="10" fill="#eee" stroke="#222" stroke-width="3"/>
                    </svg>
                    <h2 style="color: #4CAF50; font-size: 1.5rem; margin: 0;">
                        ${message}
                    </h2>
                </div>
            `;
            document.body.appendChild(loadingOverlay);
        }

        // Hide loading spinner
        function hideLoadingSpinner() {
            const existingOverlay = document.getElementById('globalLoadingOverlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }

        // Guard to prevent multiple simultaneous availability checks
        let isCheckingAvailability = false;

        // Guard to prevent multiple simultaneous QR processing
        let isProcessingQR = false;
        let lastGlobalQRTime = 0;

        // Handle QR scan result
        function onQRCodeDetected(pokemonNumber, rawData) {
            console.log('Pokemon detected:', pokemonNumber);
            
            // Global debounce to prevent rapid fire QR detections
            const now = Date.now();
            if (lastGlobalQRTime && (now - lastGlobalQRTime) < 3000) {
                console.log('üö´ Global QR debounce: Too soon after last detection, ignoring');
                return;
            }
            lastGlobalQRTime = now;
            
            // Prevent multiple simultaneous QR processing
            if (isProcessingQR) {
                console.log('QR processing already in progress, ignoring duplicate');
                return;
            }
            
            // Prevent multiple simultaneous checks
            if (isCheckingAvailability) {
                console.log('Availability check already in progress, ignoring duplicate');
                return;
            }
            
            isProcessingQR = true;
            isCheckingAvailability = true;
            
            // Store Pokemon number globally for use after minigame
            window.currentPokemonNumber = pokemonNumber;
            
            // Stop scanning
            if (qrScanner) {
                qrScanner.stopScanning();
            }
            
            // Show loading spinner while checking user data and Pokemon availability
            showLoadingSpinner('Checking Pokemon availability...');
            
            // Check user data and Pokemon availability upfront
            checkPokemonAvailability(pokemonNumber).then(result => {
                hideLoadingSpinner();
                isCheckingAvailability = false;
                isProcessingQR = false; // Reset QR processing guard
                
                if (!result.canCatch) {
                    // Show appropriate error message and return to scanner
                    if (result.reason === 'duplicate') {
                        showDuplicatePokemonModal(pokemonNumber, result.message);
                    } else if (result.reason === 'user_not_found') {
                        alert(`‚ùå ${result.message}\n\nPlease make sure you're logged in properly.`);
                        showUIState(UI_STATES.SCANNER);
                    } else {
                        alert(`‚ùå ${result.message}`);
                        showUIState(UI_STATES.SCANNER);
                    }
                    return;
                }
                
                // Store user data for later use
                window.currentUserData = result.userData;
                
                // Pokemon can be caught - load Pokemon data and show encounter
                loadPokemonData(pokemonNumber).then(pokemonData => {
                    if (pokemonData) {
                        currentPokemonData = pokemonData;
                        showPokemonEncounter(pokemonData, result.userData);
                    } else {
                        alert('Failed to load Pokemon data. Please try again.');
                        showUIState(UI_STATES.SCANNER);
                    }
                }).catch(error => {
                    console.error('Error loading Pokemon data:', error);
                    alert('Failed to load Pokemon data. Please try again.');
                    showUIState(UI_STATES.SCANNER);
                });
                
            }).catch(error => {
                console.error('Error checking Pokemon availability:', error);
                hideLoadingSpinner();
                isCheckingAvailability = false;
                isProcessingQR = false; // Reset QR processing guard
                alert(`Failed to check Pokemon availability: ${error.message}`);
                showUIState(UI_STATES.SCANNER);
            });
        }

        // Check if Pokemon can be caught by user
        async function checkPokemonAvailability(pokemonNumber) {
            try {
                // Get current user
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    return {
                        canCatch: false,
                        reason: 'user_not_found',
                        message: 'User not authenticated. Please log in again.'
                    };
                }
                
                // Get user data - either works or fails
                const userData = await CatchPokemonService.getUserData(currentUser.email);
                
                // Check if Pokemon can be caught
                const catchCheck = CatchPokemonService.canCatchPokemon(pokemonNumber, userData);
                
                return {
                    ...catchCheck,
                    userData
                };
                
            } catch (error) {
                console.error('Error checking Pokemon availability:', error);
                throw error;
            }
        }

        // Show Pokemon encounter screen
        async function showPokemonEncounter(pokemonData, userData = null) {
            document.getElementById('encounterPokemonImage').src = 
                pokemonData.sprites?.official_artwork || pokemonData.sprites?.front_default || '';
            document.getElementById('encounterPokemonName').textContent = pokemonData.name;
            
            // Use pre-fetched user data if available, otherwise fetch it
            let userInfo = userData;
            if (!userInfo) {
                try {
                    const currentUser = AuthService.getCurrentUser();
                    if (currentUser && currentUser.email) {
                        userInfo = await CatchPokemonService.getUserData(currentUser.email);
                        window.currentUserData = userInfo;
                    }
                } catch (error) {
                    console.error('Error getting user data in encounter:', error);
                }
            }
            
            // Display pokeball count and update UI
            if (userInfo) {
                document.getElementById('pokeballCount').textContent = userInfo.pokeballCount;
                
                // Check if user can catch with pokeball
                const catchCheck = CatchPokemonService.canCatchWithPokeball(window.currentPokemonNumber, userInfo);
                
                if (catchCheck.canCatch) {
                    // User has pokeballs - show normal catch option
                    document.getElementById('pokeballCountDisplay').classList.remove('empty');
                    document.getElementById('defaultActions').classList.remove('hidden');
                    document.getElementById('noPokeballs').classList.add('hidden');
                    document.getElementById('noPokeballActions').classList.add('hidden');
                } else {
                    showNoPokeballs();
                }
            }
            
            showUIState(UI_STATES.ENCOUNTER);
        }

        // Check pokeball count and display appropriate UI
        async function checkAndDisplayPokeballCount() {
            try {
                // Get current user
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    throw new Error('User not authenticated');
                }

                // Get pokeball count
                const pokeballCount = await CatchPokemonService.getUserPokeballCount(currentUser.email);
                document.getElementById('pokeballCount').textContent = pokeballCount;

                // Update UI based on pokeball count
                if (pokeballCount > 0) {
                    // User has pokeballs - show normal catch option
                    document.getElementById('pokeballCountDisplay').classList.remove('empty');
                    document.getElementById('defaultActions').classList.remove('hidden');
                    document.getElementById('noPokeballs').classList.add('hidden');
                    document.getElementById('noPokeballActions').classList.add('hidden');
                } else {
                    showNoPokeballs();
                }

            } catch (error) {
                console.error('Error checking pokeball count:', error);
                throw new Error('Unable to connect to game server. Please try again.');
            }
        }

        // Show no pokeballs UI
        function showNoPokeballs() {
            document.getElementById('pokeballCount').textContent = '0';
            document.getElementById('pokeballCountDisplay').classList.add('empty');
            document.getElementById('defaultActions').classList.add('hidden');
            document.getElementById('noPokeballs').classList.remove('hidden');
            document.getElementById('noPokeballActions').classList.remove('hidden');
        }

        // Start throw animation
        function startThrowAnimation() {
            if (!currentPokemonData) {
                alert('No Pokemon data available!');
                return;
            }
            
            // Set up throw screen
            document.getElementById('throwPokemonSprite').src = 
                currentPokemonData.sprites?.official_artwork || currentPokemonData.sprites?.front_default || '';
            
            showUIState(UI_STATES.THROW);
            
            // Initialize pokeball throw logic
            const pokeballElem = document.getElementById('pokeball');
            const targetElem = document.getElementById('throwPokemonSprite');
            
            // Use existing PokeballThrow class if available
            if (typeof PokeballThrow !== 'undefined') {
                new PokeballThrow({
                    pokeballElem,
                    targetElem,
                    onThrow: async function() {
                        await handleCatchPokemon();
                    }
                });
            } else {
                // Simple fallback - just catch on click
                pokeballElem.onclick = async function() {
                    await handleCatchPokemon();
                };
            }
        }

        // Handle running away
        function runAway() {
            console.log('üèÉ Player chose to run away');
            currentPokemonData = null;
            showUIState(UI_STATES.SCANNER);
        }

        // Handle catching Pokemon - Always succeeds when pokeball is thrown
        async function handleCatchPokemon() {
            if (!currentPokemonData) {
                alert('No Pokemon to catch!');
                return;
            }
            
            try {
                console.log(`üéØ Attempting to catch ${currentPokemonData.name}...`);
                
                // Show loading spinner while catching Pokemon
                showLoadingSpinner('Catching Pokemon...');
                
                // Use the catch service - either works or fails
                const result = await CatchPokemonService.catchPokemonOptimized(
                    currentPokemonData.id, 
                    window.currentUserData
                );
                
                hideLoadingSpinner();
                
                if (result.success) {
                    // Pokemon caught successfully
                    showCatchSuccessMessage(currentPokemonData.name);
                } else {
                    // Clear failure - no fallbacks
                    if (result.error.includes('No pokeballs available')) {
                        alert(`‚ùå No Pok√©balls available! Play the minigame to earn more.`);
                        showUIState(UI_STATES.ENCOUNTER);
                    } else {
                        alert(`‚ùå Failed to catch ${currentPokemonData.name}: ${result.error}`);
                        returnToScanner();
                    }
                }
                
            } catch (error) {
                hideLoadingSpinner();
                console.error('Catch error:', error);
                alert(`‚ùå Error catching Pokemon: ${error.message}`);
                returnToScanner();
            }
        }

        // Show catch success message and return to scanner
        async function showCatchSuccessMessage(pokemonName, isDemo = false) {
            const demoText = isDemo ? ' (Demo mode)' : '';
            
            // Get updated pokeball count to show in success message
            let pokeballInfo = '';
            if (!isDemo && typeof CatchPokemonService !== 'undefined') {
                try {
                    const currentUser = AuthService.getCurrentUser();
                    if (currentUser && currentUser.email) {
                        const remainingPokeballs = await CatchPokemonService.getUserPokeballCount(currentUser.email);
                        pokeballInfo = `<div style="margin-top: 15px; color: #ffcc02; font-size: 1rem;">
                            ‚öæ Pok√©balls remaining: ${remainingPokeballs}
                        </div>`;
                    }
                } catch (error) {
                    console.error('Error getting updated pokeball count:', error);
                }
            }
            
            // Create a nice success overlay
            const successOverlay = document.createElement('div');
            successOverlay.className = 'modal-overlay';
            successOverlay.style.background = 'rgba(0,0,0,0.8)';
            successOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üéâ</div>
                    <h2 style="color: #4CAF50; font-size: 2rem; margin-bottom: 15px;">
                        ${pokemonName} Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${pokemonName} has been added to your Pok√©dex${demoText}
                    </p>
                    ${pokeballInfo}
                    <button onclick="returnToMainMenu()" 
                            style="background: linear-gradient(145deg, #4CAF50, #45a049); 
                                   color: white; padding: 15px 30px; border: none; 
                                   border-radius: 25px; font-size: 1.1rem; cursor: pointer;
                                   margin-top: 20px;">
                        Return to Main Menu
                    </button>
                </div>
            `;
            
            document.body.appendChild(successOverlay);
        }

        // Return to main menu and clean up
        function returnToMainMenu() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Redirect to main menu
            window.location.href = '/index.html';
        }

        // Show duplicate Pokemon modal with nice UI
        function showDuplicatePokemonModal(pokemonNumber, message) {
            // Create a nice error overlay
            const errorOverlay = document.createElement('div');
            errorOverlay.className = 'modal-overlay';
            errorOverlay.style.background = 'rgba(0,0,0,0.8)';
            errorOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üîÑ</div>
                    <h2 style="color: #ff9800; font-size: 2rem; margin-bottom: 15px;">
                        Already Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${message}
                    </p>
                    <p style="font-size: 1rem; color: #ffcc02; margin-bottom: 30px;">
                        Try scanning a different Pok√©mon QR code to catch a new one!
                    </p>
                    <button onclick="closeDuplicateModal()" 
                            style="background: linear-gradient(145deg, #2196F3, #1976D2); 
                                   color: white; padding: 15px 30px; border: none; 
                                   border-radius: 25px; font-size: 1.1rem; cursor: pointer;
                                   margin-right: 10px;">
                        Continue Scanning
                    </button>
                    <button onclick="returnToMainMenu()" 
                            style="background: linear-gradient(145deg, #6c757d, #5a6268); 
                                   color: white; padding: 15px 30px; border: none; 
                                   border-radius: 25px; font-size: 1.1rem; cursor: pointer;">
                        Main Menu
                    </button>
                </div>
            `;
            
            document.body.appendChild(errorOverlay);
            
            // Auto-close and return to scanner after 6 seconds if no action taken
            setTimeout(() => {
                if (document.body.contains(errorOverlay)) {
                    closeDuplicateModal();
                }
            }, 6000);
        }

        // Close duplicate modal and return to scanner
        function closeDuplicateModal() {
            // Remove the duplicate error overlay
            const errorOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            errorOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Return to scanner
            showUIState(UI_STATES.SCANNER);
        }

        // Return to scanner and clean up (for other cases like errors)
        function returnToScanner() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Reset and go back to scanner
            currentPokemonData = null;
            showUIState(UI_STATES.SCANNER);
        }

        // Minigame completion guard to prevent duplicates
        let isMinigameCatchInProgress = false;

        // Minigame completed - actually catch the Pokemon (no pokeball consumption)
        async function catchPokemonViaMinigame() {
            // Prevent multiple simultaneous calls that could create duplicates
            if (isMinigameCatchInProgress) {
                console.log('Minigame catch already in progress, ignoring duplicate call');
                return;
            }
            
            isMinigameCatchInProgress = true;
            
            try {
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    console.log('User not authenticated for minigame completion');
                    return;
                }

                console.log('Minigame completed successfully - catching Pokemon without consuming pokeballs');
                
                // Hide ALL UI elements immediately to prevent "No Pokeballs" screen from showing
                document.getElementById('noPokeballActions').classList.add('hidden');
                document.getElementById('encounterModal').classList.add('hidden');
                document.getElementById('throwModal').classList.add('hidden');
                
                // Show a loading message with rotating SVG pokeball while catching
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'minigameLoadingOverlay';
                loadingOverlay.className = 'modal-overlay';
                loadingOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                `;
                loadingOverlay.innerHTML = `
                    <style>
                        @keyframes rotatePokeball {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                        .rotating-pokeball-svg {
                            width: 80px;
                            height: 80px;
                            animation: rotatePokeball 1.5s linear infinite;
                            margin-bottom: 20px;
                            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
                        }
                    </style>
                    <div style="text-align: center; color: white; padding: 40px;">
                        <svg class="rotating-pokeball-svg" width="80" height="80" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="60" cy="60" r="55" stroke="#222" stroke-width="5" fill="#fff"/>
                            <path d="M5 60a55 55 0 0 1 110 0" fill="#e53935" stroke="#222" stroke-width="5"/>
                            <circle cx="60" cy="60" r="20" stroke="#222" stroke-width="5" fill="#fff"/>
                            <circle cx="60" cy="60" r="10" fill="#eee" stroke="#222" stroke-width="3"/>
                        </svg>
                        <h2 style="color: #4CAF50; font-size: 1.5rem; margin: 0;">
                            Catching Pokemon...
                        </h2>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
                
                // Actually catch the Pokemon using the special minigame catch method
                const result = await CatchPokemonService.catchPokemonViaMinigame(
                    window.currentPokemonNumber, 
                    window.currentUserData
                );
                
                // Remove loading overlay
                const loadingEl = document.getElementById('minigameLoadingOverlay');
                if (loadingEl) {
                    document.body.removeChild(loadingEl);
                }
                
                if (result.success) {
                    console.log('Pokemon caught successfully via minigame:', result.pokemon.name);
                    console.time('Success message display time');
                    // Show the same success message as normal catch but with "Back to Menu" button
                    showMinigameSuccessMessage(result.pokemon.name);
                    console.timeEnd('Success message display time');
                    // Reset guard flag on success
                    isMinigameCatchInProgress = false;
                } else {
                    console.error('Minigame catch failed:', result.error);
                    alert(`Failed to catch Pokemon: ${result.error}`);
                    // Return to scanner on failure
                    window.currentPokemonNumber = null;
                    currentPokemonData = null;
                    setUIState(UI_STATES.SCANNER);
                    // Reset guard flag on failure
                    isMinigameCatchInProgress = false;
                }
                
            } catch (error) {
                console.error('Error completing minigame:', error);
                alert('Error completing minigame. Please try again.');
                // Remove loading overlay if it exists
                const loadingEl = document.getElementById('minigameLoadingOverlay');
                if (loadingEl) {
                    document.body.removeChild(loadingEl);
                }
                // Return to scanner on error
                window.currentPokemonNumber = null;
                currentPokemonData = null;
                setUIState(UI_STATES.SCANNER);
            } finally {
                // Always reset the guard flag to allow future minigame attempts
                isMinigameCatchInProgress = false;
            }
        }

        // Show minigame completion success message (same as catch success but different button)
        function showMinigameSuccessMessage(pokemonName) {
            console.log('Starting to create success overlay...');
            
            // Create a nice success overlay (same style as normal catch)
            const successOverlay = document.createElement('div');
            successOverlay.className = 'modal-overlay';
            successOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;
            
            successOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px; background: rgba(0,0,0,0.9); border-radius: 20px; max-width: 90vw;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üéâ</div>
                    <h2 style="color: #4CAF50; font-size: 2rem; margin-bottom: 15px;">
                        ${pokemonName} Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${pokemonName} has been added to your Pok√©dex
                    </p>
                    <button onclick="backToMenu()" 
                            style="background: linear-gradient(145deg, #4CAF50, #45a049); 
                                   color: white; padding: 15px 30px; border: none; 
                                   border-radius: 25px; font-size: 1.1rem; cursor: pointer;
                                   margin-top: 20px;">
                        Back to Menu
                    </button>
                </div>
            `;
            
            console.log('üéÆ About to append success overlay to DOM...');
            document.body.appendChild(successOverlay);
            console.log('üéÆ Success overlay added to DOM!');
        }

        // Back to menu function for minigame completion
        function backToMenu() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Clear stored Pokemon data and go back to main menu
            window.currentPokemonNumber = null;
            currentPokemonData = null;
            
            // Navigate to main menu
            window.location.href = '/index.html';
        }

        // Load Pokemon data
        async function loadPokemonData(pokemonNumber) {
            try {
                document.getElementById('videoDebugInfo').textContent = 'Loading Pokemon data...';
                
                // Try to load from local JSON file first
                const response = await fetch('/legacy-react/src/data/pokemon.json');
                
                if (response.ok) {
                    const pokemonData = await response.json();
                    const pokemon = pokemonData.find(p => p.id === pokemonNumber);
                    
                    if (pokemon) {
                        document.getElementById('videoDebugInfo').textContent = '';
                        return {
                            id: pokemon.id,
                            name: pokemon.name.charAt(0).toUpperCase() + pokemon.name.slice(1),
                            types: pokemon.types,
                            sprites: pokemon.sprites,
                            stats: pokemon.stats
                        };
                    }
                }
                
                // No fallback - if our service doesn't work, fail clearly
                throw new Error('Pokemon not found in our database');
                
            } catch (error) {
                console.error('Error loading Pokemon data:', error);
                document.getElementById('videoDebugInfo').textContent = 'Failed to load Pokemon data';
                throw error; // Don't return null, throw the error
            }
        }

        // QR Scanner Class
        class QRScanner {
            constructor() {
                this.video = document.getElementById('qrVideo');
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.scanning = false;
                this.stream = null;
                this.animationId = null; // Track animation frame ID
                this.scannerId = null; // Unique scanner session ID
                this.lastQRTime = 0; // Timestamp of last QR detection
                
                console.log('[QRScanner] Initializing...');
                this.initializeScanner();
            }
            
            async initializeScanner() {
                try {
                    console.log('üîß Initializing QR scanner...');
                    
                    // Check authentication if AuthService exists
                    if (typeof AuthService !== 'undefined') {
                        await AuthService.restoreAuthFromSession();
                        
                        if (!AuthService.isAuthenticated()) {
                            document.getElementById('videoDebugInfo').innerHTML = 
                                '<span style="color: #ff6b6b;">‚ö†Ô∏è Authentication required. Please log in.</span>';
                            return;
                        }
                    }
                    
                    console.log('‚úÖ Authentication OK, starting camera setup...');
                    await this.setupCamera();
                    console.log('‚úÖ Scanner initialization complete');
                    
                } catch (error) {
                    console.error('Scanner initialization error:', error);
                    document.getElementById('videoDebugInfo').innerHTML = 
                        `<span style="color: #ff6b6b;">‚ùå Scanner init failed: ${error.message}</span>`;
                }
            }
            
            async setupCamera() {
                try {
                    console.log('üé• Setting up camera...');
                    
                    // Check if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Camera not supported on this device');
                    }
                    
                    // Try multiple camera configurations for better mobile compatibility
                    let stream = null;
                    const constraints = [
                        // First try: Prefer back camera
                        { video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } } },
                        // Fallback: Any camera
                        { video: { width: { ideal: 640 }, height: { ideal: 480 } } },
                        // Last resort: Basic video
                        { video: true }
                    ];
                    
                    for (let i = 0; i < constraints.length; i++) {
                        try {
                            console.log(`üé• Trying camera constraint ${i + 1}:`, constraints[i]);
                            stream = await navigator.mediaDevices.getUserMedia(constraints[i]);
                            console.log(`‚úÖ Camera constraint ${i + 1} worked!`);
                            break;
                        } catch (err) {
                            console.log(`‚ùå Camera constraint ${i + 1} failed:`, err.message);
                            if (i === constraints.length - 1) {
                                throw err; // Re-throw the last error
                            }
                        }
                    }
                    
                    if (!stream) {
                        throw new Error('Could not access camera with any configuration');
                    }
                    
                    this.video.srcObject = stream;
                    this.stream = stream;
                    
                    // Wait for video to be ready with better mobile support
                    return new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Camera setup timeout'));
                        }, 10000); // 10 second timeout
                        
                        const onReady = () => {
                            clearTimeout(timeout);
                            console.log(`üìπ Video ready: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            
                            this.canvas.width = this.video.videoWidth || 640;
                            this.canvas.height = this.video.videoHeight || 480;
                            
                            document.getElementById('videoDebugInfo').innerHTML = 
                                '<span style="color: #4ecdc4;">üì∑ Camera ready - Point at a Pok√©mon QR code</span>';
                            
                            // Start scanning after a small delay to ensure video is fully ready
                            setTimeout(() => {
                                this.startScanning();
                                resolve();
                            }, 500);
                        };
                        
                        if (this.video.readyState >= 2) {
                            onReady();
                        } else {
                            this.video.addEventListener('loadedmetadata', onReady, { once: true });
                            this.video.addEventListener('canplay', onReady, { once: true });
                        }
                    });
                        
                } catch (error) {
                    console.error('Camera setup error:', error);
                    document.getElementById('videoDebugInfo').innerHTML = 
                        `<span style="color: #ff6b6b;">‚ùå Camera error: ${error.message}</span>`;
                    throw error;
                }
            }
            
            startScanning() {
                if (this.scanning) return;
                
                this.scanning = true;
                this.scannerId = Date.now(); // Create unique session ID
                console.log('üéØ Starting QR scan loop... Session ID:', this.scannerId);
                document.getElementById('videoDebugInfo').innerHTML = 
                    '<span style="color: #4ecdc4;">üîç Scanning for QR codes...</span>';
                    
                this.scanLoop();
            }
            
            stopScanning() {
                this.scanning = false;
                this.scannerId = null; // Invalidate session
                console.log('‚èπÔ∏è Stopping QR scanner - Session invalidated');
                
                // Cancel any pending animation frame
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    console.log('üõë Cancelled pending animation frame');
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }
            
            scanLoop() {
                // STRONG SESSION VALIDATION - multiple checks to ensure we should continue
                const currentSessionId = this.scannerId;
                
                // Check 1: Basic scanning state
                if (!this.scanning) {
                    console.log('üõë Scan loop terminated - scanning=false');
                    this.animationId = null;
                    return;
                }
                
                // Check 2: Session validity
                if (!currentSessionId || this.scannerId !== currentSessionId) {
                    console.log('üõë Scan loop terminated - session invalid');
                    this.animationId = null;
                    return;
                }
                
                // Check 3: Video availability
                if (!this.video) {
                    console.log('üõë Scan loop terminated - no video');
                    this.animationId = null;
                    return;
                }
                
                // Check 4: Video readiness with mobile-friendly checks
                if (this.video.readyState === this.video.HAVE_ENOUGH_DATA && 
                    this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                    
                    try {
                        // Update canvas size if video dimensions changed (mobile rotation)
                        if (this.canvas.width !== this.video.videoWidth || this.canvas.height !== this.video.videoHeight) {
                            this.canvas.width = this.video.videoWidth;
                            this.canvas.height = this.video.videoHeight;
                            console.log(`üìπ Canvas resized to ${this.canvas.width}x${this.canvas.height}`);
                        }
                        
                        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Scan for QR code using jsQR
                        if (typeof jsQR !== 'undefined') {
                            const code = jsQR(imageData.data, imageData.width, imageData.height);
                            
                            if (code) {
                                console.log('üéØ QR Code detected:', code.data);
                                this.handleQRCode(code.data);
                                return; // Stop scanning after successful detection
                            }
                        }
                    } catch (error) {
                        console.error('Error in scan loop:', error);
                        // Continue scanning despite errors
                    }
                }
                
                // FINAL CHECK before scheduling next frame - triple validation
                if (this.scanning && this.scannerId === currentSessionId && currentSessionId !== null) {
                    // Use setTimeout for mobile compatibility (more predictable than requestAnimationFrame on mobile)
                    this.animationId = requestAnimationFrame(() => this.scanLoop());
                } else {
                    console.log('üõë Final check failed - stopping scan loop');
                    this.animationId = null;
                }
            }
            
            handleQRCode(data) {
                // IMMEDIATE COMPLETE STOP - no more frames should execute
                this.scanning = false;
                const oldSessionId = this.scannerId;
                this.scannerId = null; // Invalidate session immediately
                
                // Cancel any pending animation frame immediately
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                console.log(`üõë QR scanner COMPLETELY STOPPED - Session ${oldSessionId} invalidated`);
                
                // Add timestamp to prevent rapid duplicate processing
                const now = Date.now();
                if (this.lastQRTime && (now - this.lastQRTime) < 2000) {
                    console.log('üö´ QR detected too soon after last one, ignoring');
                    return;
                }
                this.lastQRTime = now;
                
                // Extract Pokemon number from QR data
                const pokemonNumber = this.extractPokemonNumber(data);
                
                if (pokemonNumber && pokemonNumber > 0 && pokemonNumber <= 1010) { // Valid Pokemon range
                    console.log('‚úÖ Valid Pokemon QR detected, processing...');
                    // Call immediately without delay to prevent any more scan loops
                    onQRCodeDetected(pokemonNumber, data);
                } else {
                    console.log('‚ùå Invalid Pokemon QR code, will resume scanning');
                    document.getElementById('videoDebugInfo').innerHTML = 
                        '<span style="color: #ff6b6b;">‚ùå Invalid Pok√©mon QR code</span>';
                    
                    // Resume scanning after 2 seconds for invalid codes
                    setTimeout(() => {
                        if (currentState === UI_STATES.SCANNER && !this.scanning) {
                            document.getElementById('videoDebugInfo').innerHTML = 
                                '<span style="color: #4ecdc4;">üîç Scanning for QR codes...</span>';
                            this.startScanning(); // Use startScanning to create new session
                        }
                    }, 2000);
                }
            }
            
            extractPokemonNumber(data) {
                // Handle various QR code formats
                console.log('Parsing QR data:', data);
                
                // Direct number
                if (/^\d+$/.test(data)) {
                    return parseInt(data);
                }
                
                // Pokemon:123 format
                if (data.toLowerCase().includes('pokemon')) {
                    const match = data.match(/pokemon[:\s]*(\d+)/i);
                    if (match) return parseInt(match[1]);
                }
                
                // Extract any number from the string
                const numberMatch = data.match(/(\d+)/);
                if (numberMatch) {
                    return parseInt(numberMatch[1]);
                }
                
                return null;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Pokemon Scanner - Starting...');
            
            // Show scanner UI initially
            showUIState(UI_STATES.SCANNER);
            
            // Initialize QR scanner
            qrScanner = new QRScanner();
        });
    </script>
</body>
</html>
