<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catch Pokemon - QR Scanner</title>
    <link rel="stylesheet" href="styles/pokemon-design-system.css">    <style>
    /* Page-specific styles for clean Pokemon card design */
    
    /* Simple pokeball hover effect */
    #pokeball:hover {
        transform: scale(1.05);
    }
    
    .pokemon-scanner-inner {
        background: #000;
        border-radius: var(--radius-lg);
        padding: var(--space-md);
        position: relative;
        overflow: hidden;
        box-shadow: var(--shadow-md);
    }

    #qrVideo {
        width: 100%;
        height: 300px;
        object-fit: cover;
        border-radius: var(--radius-md);
        display: block;
    }

    .pokemon-scanner-overlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        border: 3px solid var(--pokemon-yellow);
        border-radius: var(--radius-md);
        box-shadow: 0 0 0 4px rgba(255, 222, 0, 0.3);
        pointer-events: none;
        z-index: 10;
    }

    .pokemon-scanner-corners {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 200px;
        height: 200px;
        pointer-events: none;
        z-index: 11;
    }

    .corner {
        position: absolute;
        width: 20px;
        height: 20px;
        border: 4px solid var(--pokemon-yellow);
    }

    .corner.top-left {
        top: -2px;
        left: -2px;
        border-right: none;
        border-bottom: none;
        border-top-left-radius: 10px;
    }

    .corner.top-right {
        top: -2px;
        right: -2px;
        border-left: none;
        border-bottom: none;
        border-top-right-radius: 10px;
    }

    .corner.bottom-left {
        bottom: -2px;
        left: -2px;
        border-right: none;
        border-top: none;
        border-bottom-left-radius: 10px;
    }

    .corner.bottom-right {
        bottom: -2px;
        right: -2px;
        border-left: none;
        border-top: none;
        border-bottom-right-radius: 10px;
    }

    .scan-instruction {
        text-align: center;
        color: #fff;
        font-size: 1.2rem;
        margin-top: 15px;
        padding: 10px;
        background: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
    }

    /* Retro Nintendo/Game Boy Pokemon Card Style */
    .modal-overlay {
        position: fixed;
        top: 0; left: 0; right: 0; bottom: 0;
        width: 100vw; height: 100vh;
        background: linear-gradient(135deg, #2d3436 0%, #636e72 100%);
        z-index: 9999;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--space-lg);
        box-sizing: border-box;
    }

    /* Center all page content */
    .pokemon-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        width: 100%;
        max-width: 100vw;
        margin: 0 auto;
        padding: var(--space-md);
        box-sizing: border-box;
    }

    /* Retro Pokemon Card */
    .pokemon-retro-card {
        background: #f8f9fa;
        border: 4px solid #2d3436;
        border-radius: 20px;
        box-shadow: 
            0 8px 16px rgba(0,0,0,0.3),
            inset 0 2px 0 rgba(255,255,255,0.8);
        max-width: 350px;
        width: 100%;
        position: relative;
        overflow: hidden;
    }

    /* Type-based card headers */
    .pokemon-type-header {
        height: 8px;
        width: 100%;
    }

    .pokemon-type-header.fire { background: linear-gradient(90deg, #ff6b6b, #ee5a24); }
    .pokemon-type-header.water { background: linear-gradient(90deg, #74b9ff, #0984e3); }
    .pokemon-type-header.grass { background: linear-gradient(90deg, #00b894, #00a085); }
    .pokemon-type-header.electric { background: linear-gradient(90deg, #fdcb6e, #f39c12); }
    .pokemon-type-header.psychic { background: linear-gradient(90deg, #fd79a8, #e84393); }
    .pokemon-type-header.fighting { background: linear-gradient(90deg, #e17055, #d63031); }
    .pokemon-type-header.normal { background: linear-gradient(90deg, #ddd, #999); }
    .pokemon-type-header.flying { background: linear-gradient(90deg, #a29bfe, #6c5ce7); }
    .pokemon-type-header.poison { background: linear-gradient(90deg, #9b59b6, #8e44ad); }
    .pokemon-type-header.ground { background: linear-gradient(90deg, #f39c12, #e67e22); }
    .pokemon-type-header.rock { background: linear-gradient(90deg, #95a5a6, #7f8c8d); }
    .pokemon-type-header.bug { background: linear-gradient(90deg, #2ecc71, #27ae60); }
    .pokemon-type-header.ghost { background: linear-gradient(90deg, #9b59b6, #663399); }
    .pokemon-type-header.steel { background: linear-gradient(90deg, #bdc3c7, #95a5a6); }
    .pokemon-type-header.fire { background: linear-gradient(90deg, #e74c3c, #c0392b); }
    .pokemon-type-header.ice { background: linear-gradient(90deg, #74b9ff, #0984e3); }
    .pokemon-type-header.dragon { background: linear-gradient(90deg, #6c5ce7, #5f3dc4); }
    .pokemon-type-header.dark { background: linear-gradient(90deg, #2d3436, #636e72); }
    .pokemon-type-header.fairy { background: linear-gradient(90deg, #fd79a8, #e84393); }

    /* Pokemon Image Container */
    .pokemon-image-retro {
        background: #ffffff;
        border: 3px solid #2d3436;
        border-radius: 12px;
        padding: var(--space-md);
        margin: var(--space-md);
        position: relative;
    }

    .pokemon-image-retro::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #ddd, #fff, #ddd);
    }

    /* Pokemon Name Styling */
    .pokemon-name-retro {
        font-family: 'Courier New', monospace;
        font-size: 1.8rem;
        font-weight: bold;
        color: #2d3436;
        margin: var(--space-md) 0;
        text-transform: uppercase;
        letter-spacing: 2px;
        text-align: center;
        text-shadow: 1px 1px 0 #fff;
    }

    /* Type Badge Retro */
    .pokemon-type-badge-retro {
        display: inline-block;
        padding: var(--space-xs) var(--space-sm);
        border: 2px solid #2d3436;
        border-radius: 15px;
        font-family: 'Courier New', monospace;
        font-size: var(--font-size-sm);
        font-weight: bold;
        text-transform: uppercase;
        margin: 0 var(--space-xs);
        color: #fff;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }

    .pokemon-type-badge-retro.fire { background: #e74c3c; }
    .pokemon-type-badge-retro.water { background: #3498db; }
    .pokemon-type-badge-retro.grass { background: #2ecc71; }
    .pokemon-type-badge-retro.electric { background: #f1c40f; color: #2d3436; text-shadow: none; }
    .pokemon-type-badge-retro.psychic { background: #9b59b6; }
    .pokemon-type-badge-retro.fighting { background: #e67e22; }
    .pokemon-type-badge-retro.normal { background: #95a5a6; }
    .pokemon-type-badge-retro.flying { background: #6c5ce7; }
    .pokemon-type-badge-retro.poison { background: #8e44ad; }
    .pokemon-type-badge-retro.ground { background: #f39c12; color: #2d3436; text-shadow: none; }
    .pokemon-type-badge-retro.rock { background: #7f8c8d; }
    .pokemon-type-badge-retro.bug { background: #27ae60; }
    .pokemon-type-badge-retro.ghost { background: #663399; }
    .pokemon-type-badge-retro.steel { background: #bdc3c7; color: #2d3436; text-shadow: none; }
    .pokemon-type-badge-retro.ice { background: #74b9ff; }
    .pokemon-type-badge-retro.dragon { background: #5f3dc4; }
    .pokemon-type-badge-retro.dark { background: #2d3436; }
    .pokemon-type-badge-retro.fairy { background: #fd79a8; }

    /* Pokeball Count Retro */
    .pokemon-stats-retro {
        background: #fff;
        border: 3px solid #2d3436;
        border-radius: 8px;
        padding: var(--space-sm) var(--space-md);
        font-family: 'Courier New', monospace;
        font-weight: bold;
        font-size: var(--font-size-base);
        color: #2d3436;
        margin: var(--space-md) 0;
        display: inline-block;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
    }

    .pokemon-stats-retro.no-pokeballs {
        background: #ff6b6b;
        color: #fff;
        border-color: #e74c3c;
    }

    /* Retro Button Styling */
    .pokemon-button-retro {
        background: #74b9ff;
        color: #fff;
        border: 3px solid #2d3436;
        border-radius: 8px;
        padding: var(--space-md) var(--space-lg);
        font-family: 'Courier New', monospace;
        font-size: var(--font-size-base);
        font-weight: bold;
        text-transform: uppercase;
        cursor: pointer;
        transition: all 0.1s ease;
        box-shadow: 
            0 4px 0 #2d3436,
            0 4px 8px rgba(0,0,0,0.3);
        flex: 1;
        text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }

    .pokemon-button-retro:hover {
        transform: translateY(2px);
        box-shadow: 
            0 2px 0 #2d3436,
            0 2px 4px rgba(0,0,0,0.3);
    }

    .pokemon-button-retro:active {
        transform: translateY(4px);
        box-shadow: none;
    }

    .pokemon-button-retro.secondary {
        background: #95a5a6;
    }

    .pokemon-button-retro.danger {
        background: #e74c3c;
    }

    .pokemon-button-retro.success {
        background: #2ecc71;
    }

    /* Alert Retro */
    .pokemon-alert-retro {
        background: #ff6b6b;
        color: #fff;
        border: 3px solid #e74c3c;
        border-radius: 8px;
        padding: var(--space-md);
        margin: var(--space-sm) 0;
        font-family: 'Courier New', monospace;
        font-weight: bold;
        text-align: center;
        box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
    }

    /* Animation for scanning pulse effect */
    @keyframes scanPulse {
        0% { box-shadow: 0 0 0 0 rgba(255, 204, 2, 0.7); }
        70% { box-shadow: 0 0 0 20px rgba(255, 204, 2, 0); }
        100% { box-shadow: 0 0 0 0 rgba(255, 204, 2, 0); }
    }

    .pokemon-scanner-overlay.scanning {
        animation: scanPulse 2s infinite;
    }

    /* Fun pokeball spinning animation */
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    /* Hidden by default */
    .hidden {
        display: none !important;
    }

    /* Mobile-specific adjustments */
    @media (max-height: 700px) {
        .modal-overlay {
            padding-top: 5vh; /* Even less padding on shorter screens */
        }
        
        .pokemon-sprite-large {
            width: 50vw;
            max-width: 200px;
        }
        
        .pokemon-name {
            font-size: 1.6rem;
        }
    }

    @media (max-height: 600px) {
        .modal-overlay {
            padding-top: 2vh; /* Minimal padding on very short screens */
        }
        
        .pokemon-encounter {
            padding: 20px;
        }
    }

    /* Enhanced Mobile-specific adjustments and responsive design */
    @media (max-width: 768px) {
        .pokemon-container {
            padding: var(--space-sm);
        }
        
        .pokemon-retro-card {
            max-width: 320px;
            margin: var(--space-sm);
        }
        
        .pokemon-image-retro {
            margin: var(--space-sm);
            padding: var(--space-sm);
        }
        
        .pokemon-image-retro img,
        .pokemon-image-retro #throwPokemonSprite {
            width: 130px;
            height: 130px;
        }
        
        .pokemon-button-retro {
            padding: var(--space-sm) var(--space-md);
            font-size: var(--font-size-sm);
        }
        
        .pokemon-name-retro {
            font-size: 1.4rem;
        }
        
        /* Mobile QR scanner */
        #qrVideo {
            height: 250px;
        }
        
        .pokemon-scanner-overlay,
        .pokemon-scanner-corners {
            width: 150px;
            height: 150px;
        }
        
        /* Smaller pokeballs on mobile */
        .pokemon-header img {
            width: 24px !important;
            height: 24px !important;
        }
        
        /* Smaller title gap on mobile */
        .pokemon-header div {
            gap: var(--space-md) !important;
        }
    }

    @media (max-height: 700px) {
        .modal-overlay {
            padding: var(--space-md);
        }
        
        .pokemon-retro-card {
            max-width: 300px;
        }
        
        .pokemon-image-retro img,
        .pokemon-image-retro #throwPokemonSprite {
            width: 110px;
            height: 110px;
        }
        
        .pokemon-name-retro {
            font-size: 1.2rem;
        }
    }

    @media (max-height: 600px) {
        .modal-overlay {
            padding: var(--space-sm);
        }
        
        .pokemon-modal-body {
            padding: var(--space-sm) !important;
        }
        
        .pokemon-image-retro {
            margin: var(--space-xs);
            padding: var(--space-xs);
        }
        
        .pokemon-image-retro img,
        .pokemon-image-retro #throwPokemonSprite {
            width: 90px;
            height: 90px;
        }
    }

    /* Simple hover effects for desktop (no complex animations) */
    @media (min-width: 769px) {
        .pokemon-button-retro:hover {
            transform: translateY(1px);
        }
    }
    </style>
</head>
<body class="pokemon-game-body">
    <div class="pokemon-container">
        <!-- Title Section - Completely Separate -->
        <div style="text-align: center; margin-bottom: var(--space-xl);">
            <div style="display: flex; align-items: center; justify-content: center; gap: var(--space-lg);">
                <img src="assets/pokeball.svg" alt="Pokeball" style="width: 32px; height: 32px; animation: spin 3s linear infinite;">
                <h1 class="pokemon-title" style="margin: 0;">Catch Pokemon</h1>
                <img src="assets/pokeball.svg" alt="Pokeball" style="width: 32px; height: 32px; animation: spin 3s linear infinite reverse;">
            </div>
        </div>

        <!-- Home Button Section - Completely Separate -->
        <div style="text-align: center; margin-bottom: var(--space-lg);">
            <button class="pokemon-btn pokemon-btn-sm" onclick="navigateHome()">
                üè† Home
            </button>
        </div>

        <!-- QR Scanner Section -->
        <div id="scannerContainer" class="pokemon-section">
            <div class="pokemon-card" style="max-width: 400px; margin: 0 auto;">
                <div class="pokemon-scanner-frame">
                    <div class="pokemon-scanner-inner">
                        <video id="qrVideo" playsinline autoplay></video>
                        <div class="pokemon-scanner-overlay scanning"></div>
                        <div class="pokemon-scanner-corners">
                            <div class="corner top-left"></div>
                            <div class="corner top-right"></div>
                            <div class="corner bottom-left"></div>
                            <div class="corner bottom-right"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Scanner Controls -->
                <div class="pokemon-flex-center mt-lg">
                    <button id="refreshScannerBtn" class="pokemon-btn pokemon-btn-primary" onclick="refreshQRScanner()">
                        üîÑ Refresh Scanner
                    </button>
                </div>
                
                <div id="videoDebugInfo" class="text-center mt-md pokemon-text-small"></div>
            </div>
        </div> <!-- End pokemon-section -->
    </div> <!-- End pokemon-container -->

    <!-- Pokemon Encounter Modal -->
    <div id="encounterModal" class="pokemon-card-modal hidden">
        <button class="pokemon-card-modal-close" onclick="runAway()">&times;</button>
        <div class="pokemon-card-modal-content">
            <div class="pokemon-trading-card">
                <!-- Trading Card Header -->
                <div id="pokemonCardHeader" class="pokemon-trading-card-header normal">
                    <div class="pokemon-trading-card-hp" id="pokemonHP">HP 39</div>
                    <div class="pokemon-trading-card-name" id="encounterPokemonName">Loading...</div>
                </div>
                
                <!-- Pokemon Image -->
                <div class="pokemon-trading-card-image-container">
                    <img id="encounterPokemonImage" class="pokemon-trading-card-image" src="" alt="Pokemon">
                </div>
                
                <!-- Type Badges -->
                <div id="pokemonTypes" class="pokemon-trading-card-types">
                    <!-- Type badges will be added here dynamically -->
                </div>
                
                <!-- Pokemon Stats -->
                <div class="pokemon-trading-card-stats" id="pokemonStatsContainer">
                    <!-- Stats will be populated dynamically -->
                </div>
                
                <!-- Pokeball Count Display -->
                <div style="padding: 0 var(--space-md) var(--space-md);">
                    <div id="pokeballCountDisplay" class="pokemon-stats-retro">
                        POKEBALLS: <span id="pokeballCount">0</span>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div class="pokemon-trading-card-actions">
                    <div id="defaultActions" style="display: flex; gap: var(--space-md); width: 100%; justify-content: center;">
                        <button class="pokemon-button-retro success" onclick="startThrowAnimation()">
                            CATCH!
                        </button>
                        <button class="pokemon-button-retro secondary" onclick="runAway()">
                            RUN AWAY
                        </button>
                    </div>

                    <!-- No Pokeballs Message -->
                    <div id="noPokeballs" class="hidden" style="text-align: center; width: 100%;">
                        <div class="pokemon-alert-retro" style="margin-bottom: var(--space-md);">
                            <div style="font-size: var(--font-size-lg); margin-bottom: var(--space-xs); font-weight: bold;">NO MORE POKEBALLS!</div>
                            <div style="font-size: var(--font-size-sm);">Complete minigame to catch POKEMON</div>
                        </div>
                        
                        <!-- No Pokeballs Actions -->
                        <div id="noPokeballActions" style="display: flex; gap: var(--space-md); justify-content: center;">
                            <button class="pokemon-button-retro success" onclick="MinigameLibrary.showMinigameSelection()">
                                MINIGAME
                            </button>
                            <button class="pokemon-button-retro secondary" onclick="runAway()">
                                RUN AWAY
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Pokeball Throw Animation -->
    <div id="throwModal" class="pokemon-modal-overlay hidden">
        <div class="pokemon-retro-card">
            <!-- Type-based header -->
            <div id="throwTypeHeader" class="pokemon-type-header normal"></div>
            
            <div class="pokemon-modal-body" style="padding: var(--space-md);">
                <div style="text-align: center;">
                    <!-- Instructions -->
                    <div class="pokemon-stats-retro" style="margin-bottom: var(--space-lg);">
                        SWIPE UP TO THROW!
                    </div>
                    
                    <!-- Target Pokemon -->
                    <div class="pokemon-image-retro" style="margin-bottom: var(--space-lg);">
                        <img id="throwPokemonSprite" src="" alt="Target Pokemon" 
                             style="width: 140px; height: 140px; object-fit: contain; display: block; margin: 0 auto;">
                    </div>
                    
                    <!-- Pokeball Container -->
                    <div style="background: #fff; border: 4px solid #2d3436; border-radius: 50%; padding: var(--space-lg); display: inline-block; margin: var(--space-md) 0; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                        <img id="pokeball" src="assets/pokeball.svg" alt="Pokeball" 
                             style="width: 60px; height: 60px; cursor: pointer;">
                    </div>
                    
                    <div style="color: #2d3436; font-family: 'Courier New', monospace; font-weight: bold; font-size: var(--font-size-base); margin-top: var(--space-md);">
                        AIM AND THROW YOUR POKEBALL!
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <!-- Include jsQR library for QR code scanning -->
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    
    <!-- Include Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Include Auth Service -->
    <script src="auth.js"></script>
    
    <!-- Include Pokemon Card Template System -->
    <script src="components/pokemon-card-templates.js"></script>
    
    <!-- Include Pokemon Encounter Modal -->
    <script src="components/pokemon-encounter-modal.js"></script>
    
    <!-- Include Catch Pokemon Service -->
    <script src="catch-pokemon-service.js"></script>
    
    <!-- Include Minigame Library -->
    <script src="minigame-library.js"></script>
    
    <!-- Include Pokeball Throw Logic -->
    <script src="throw-pokeball.js"></script>
    
    <script>
        // Global variables
        let currentPokemonData = null;
        let qrScanner = null;

        // UI State Management
        const UI_STATES = {
            SCANNER: 'scanner',
            ENCOUNTER: 'encounter', 
            THROW: 'throw'
        };

        let currentState = UI_STATES.SCANNER;

        // Show only the specified UI state
        function showUIState(state) {
            currentState = state;
            
            // Hide all containers
            document.getElementById('scannerContainer').classList.add('hidden');
            document.getElementById('encounterModal').classList.add('hidden');
            document.getElementById('throwModal').classList.add('hidden');
            
            // Show the requested state
            switch(state) {
                case UI_STATES.SCANNER:
                    document.getElementById('scannerContainer').classList.remove('hidden');
                    // Restart scanner if it exists
                    if (qrScanner && !qrScanner.scanning) {
                        qrScanner.startScanning();
                    }
                    break;
                    
                case UI_STATES.ENCOUNTER:
                    document.getElementById('encounterModal').classList.remove('hidden');
                    break;
                    
                case UI_STATES.THROW:
                    document.getElementById('throwModal').classList.remove('hidden');
                    break;
            }
        }

        // Show loading spinner with rotating pokeball
        function showLoadingSpinner(message = 'Loading...') {
            // Remove any existing spinner first
            hideLoadingSpinner();
            
            const loadingOverlay = document.createElement('div');
            loadingOverlay.id = 'globalLoadingOverlay';
            loadingOverlay.className = 'modal-overlay';
            loadingOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;
            loadingOverlay.innerHTML = `
                <style>
                    @keyframes rotatePokeball {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                    .rotating-pokeball-svg {
                        width: 80px;
                        height: 80px;
                        animation: rotatePokeball 1.5s linear infinite;
                        margin-bottom: 20px;
                        filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
                    }
                </style>
                <div style="text-align: center; color: white; padding: 40px;">
                    <svg class="rotating-pokeball-svg" width="80" height="80" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="60" cy="60" r="55" stroke="#222" stroke-width="5" fill="#fff"/>
                        <path d="M5 60a55 55 0 0 1 110 0" fill="#e53935" stroke="#222" stroke-width="5"/>
                        <circle cx="60" cy="60" r="20" stroke="#222" stroke-width="5" fill="#fff"/>
                        <circle cx="60" cy="60" r="10" fill="#eee" stroke="#222" stroke-width="3"/>
                    </svg>
                    <h2 style="color: #4CAF50; font-size: 1.5rem; margin: 0;">
                        ${message}
                    </h2>
                </div>
            `;
            document.body.appendChild(loadingOverlay);
        }

        // Hide loading spinner
        function hideLoadingSpinner() {
            const existingOverlay = document.getElementById('globalLoadingOverlay');
            if (existingOverlay) {
                existingOverlay.remove();
            }
        }

        // Guard to prevent multiple simultaneous availability checks
        let isCheckingAvailability = false;

        // Guard to prevent multiple simultaneous QR processing
        let isProcessingQR = false;
        let lastGlobalQRTime = 0;

        // Handle QR scan result with robust error handling
        function onQRCodeDetected(pokemonNumber, rawData) {
            console.log('Pokemon detected:', pokemonNumber);
            
            // Global debounce to prevent rapid fire QR detections
            const now = Date.now();
            if (lastGlobalQRTime && (now - lastGlobalQRTime) < 3000) {
                console.log('üö´ Global QR debounce: Too soon after last detection, ignoring');
                return;
            }
            lastGlobalQRTime = now;
            
            // Prevent multiple simultaneous QR processing
            if (isProcessingQR) {
                console.log('QR processing already in progress, ignoring duplicate');
                return;
            }
            
            // Prevent multiple simultaneous checks
            if (isCheckingAvailability) {
                console.log('Availability check already in progress, ignoring duplicate');
                return;
            }
            
            isProcessingQR = true;
            isCheckingAvailability = true;
            
            // Store Pokemon number globally for use after minigame
            window.currentPokemonNumber = pokemonNumber;
            
            // Stop scanning
            if (qrScanner) {
                qrScanner.stopScanning();
            }
            
            // Show loading spinner while checking user data and Pokemon availability
            showLoadingSpinner('Checking Pokemon availability...');
            
            // Use setTimeout to ensure async call doesn't block the UI
            setTimeout(async () => {
                try {
                    // Check user data and Pokemon availability upfront
                    console.log('üîç Starting Pokemon availability check...');
                    const result = await checkPokemonAvailability(pokemonNumber);
                    console.log('‚úÖ Pokemon availability check completed:', result);
                    
                    hideLoadingSpinner();
                    isCheckingAvailability = false;
                    isProcessingQR = false; // Reset QR processing guard
                    
                    if (!result.canCatch) {
                        // Show appropriate error message and return to scanner
                        if (result.reason === 'duplicate') {
                            showDuplicatePokemonModal(pokemonNumber, result.message);
                        } else if (result.reason === 'user_not_found') {
                            alert(`‚ùå ${result.message}\n\nPlease make sure you're logged in properly.`);
                            showUIState(UI_STATES.SCANNER);
                        } else {
                            alert(`‚ùå ${result.message}`);
                            showUIState(UI_STATES.SCANNER);
                        }
                        return;
                    }
                    
                    // Store user data for later use
                    window.currentUserData = result.userData;
                    
                    // Pokemon can be caught - load Pokemon data and show encounter
                    console.log('‚úÖ Pokemon can be caught, loading Pokemon data...');
                    const pokemonData = await loadPokemonData(pokemonNumber);
                    
                    if (pokemonData) {
                        currentPokemonData = pokemonData;
                        showPokemonEncounter(pokemonData, result.userData);
                    } else {
                        alert('Failed to load Pokemon data. Please try again.');
                        showUIState(UI_STATES.SCANNER);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Error in QR processing:', error);
                    hideLoadingSpinner();
                    isCheckingAvailability = false;
                    isProcessingQR = false; // Reset QR processing guard
                    
                    // Show user-friendly error message
                    const errorMessage = error.message || 'Unknown error occurred';
                    alert(`‚ùå Failed to check Pokemon availability: ${errorMessage}\n\nPlease try again.`);
                    showUIState(UI_STATES.SCANNER);
                }
            }, 100); // Small delay to ensure UI updates properly
        }

        // Check if Pokemon can be caught by user
        async function checkPokemonAvailability(pokemonNumber) {
            try {
                console.log('üîç Checking Pokemon availability for number:', pokemonNumber);
                
                // Validate that required services are available
                if (typeof AuthService === 'undefined') {
                    throw new Error('AuthService not loaded');
                }
                if (typeof CatchPokemonService === 'undefined') {
                    throw new Error('CatchPokemonService not loaded');
                }
                
                // Get current user
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    console.error('‚ùå User not authenticated:', currentUser);
                    return {
                        canCatch: false,
                        reason: 'user_not_found',
                        message: 'User not authenticated. Please log in again.'
                    };
                }
                
                console.log('‚úÖ User found:', currentUser.email);
                
                // Get user data - either works or fails
                console.log('üì° Fetching user data...');
                const userData = await CatchPokemonService.getUserData(currentUser.email);
                console.log('‚úÖ User data retrieved:', userData);
                
                // Check if Pokemon can be caught
                console.log('üéØ Checking if Pokemon can be caught...');
                const catchCheck = CatchPokemonService.canCatchPokemon(pokemonNumber, userData);
                console.log('‚úÖ Catch check result:', catchCheck);
                
                return {
                    ...catchCheck,
                    userData
                };
                
            } catch (error) {
                console.error('‚ùå Error checking Pokemon availability:', error);
                console.error('Error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                throw error;
            }
        }

        // Show Pokemon encounter screen using new PokemonEncounterModal
        async function showPokemonEncounter(pokemonData, userData = null) {
            console.log('üéØ ENCOUNTER: Showing Pokemon encounter with new modal system');
            console.log('üéØ ENCOUNTER: Pokemon data:', pokemonData);
            console.log('üéØ ENCOUNTER: User data:', userData);
            
            // Debug: Check if classes are available
            console.log('üéØ ENCOUNTER: PokemonCardTemplates available?', typeof window.PokemonCardTemplates);
            console.log('üéØ ENCOUNTER: PokemonEncounterModal available?', typeof window.PokemonEncounterModal);
            
            // Create or get the encounter modal instance
            if (!window.pokemonEncounterModalInstance) {
                if (typeof window.PokemonEncounterModal === 'undefined') {
                    console.error('üéØ ENCOUNTER: PokemonEncounterModal class is not available!');
                    alert('Error: Pokemon encounter system not loaded. Please refresh the page.');
                    return;
                }
                console.log('üéØ ENCOUNTER: Creating new instance...');
                window.pokemonEncounterModalInstance = new PokemonEncounterModal();
                console.log('üéØ ENCOUNTER: Created new encounter modal instance:', window.pokemonEncounterModalInstance);
                console.log('üéØ ENCOUNTER: Instance methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(window.pokemonEncounterModalInstance)));
            }
            
            // Debug the instance
            console.log('üéØ ENCOUNTER: Current encounterModal:', window.pokemonEncounterModalInstance);
            console.log('üéØ ENCOUNTER: show method type:', typeof window.pokemonEncounterModalInstance.show);
            
            // Get pokeball count from user data
            const pokeballCount = userData ? userData.pokeballCount : 0;
            console.log('üéØ ENCOUNTER: Pokeball count:', pokeballCount);
            
            // Show the encounter modal with Pokemon data and callbacks
            window.pokemonEncounterModalInstance.show(pokemonData, {
                pokeballCount: pokeballCount,
                onCatch: () => {
                    console.log('üéØ ENCOUNTER: Catch button clicked');
                    startThrowAnimation();
                },
                onRunAway: () => {
                    console.log('üéØ ENCOUNTER: Run away button clicked');
                    runAway();
                },
                onMinigame: () => {
                    console.log('üéØ ENCOUNTER: Minigame button clicked');
                    MinigameLibrary.showMinigameSelection();
                }
            });
        }

        // Check pokeball count and display appropriate UI
        async function checkAndDisplayPokeballCount() {
            try {
                // Get current user
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    throw new Error('User not authenticated');
                }

                // Get pokeball count
                const pokeballCount = await CatchPokemonService.getUserPokeballCount(currentUser.email);
                document.getElementById('pokeballCount').textContent = pokeballCount;

                // Update UI based on pokeball count
                if (pokeballCount > 0) {
                    // User has pokeballs - show normal catch option
                    const pokeballDisplay = document.getElementById('pokeballCountDisplay');
                    pokeballDisplay.className = 'pokemon-stats-retro';
                    
                    document.getElementById('defaultActions').classList.remove('hidden');
                    document.getElementById('noPokeballs').classList.add('hidden');
                } else {
                    showNoPokeballs();
                }

            } catch (error) {
                console.error('Error checking pokeball count:', error);
                throw new Error('Unable to connect to game server. Please try again.');
            }
        }

        // Show no pokeballs UI
        function showNoPokeballs() {
            document.getElementById('pokeballCount').textContent = '0';
            // Change pokeball count to alert styling
            const pokeballDisplay = document.getElementById('pokeballCountDisplay');
            pokeballDisplay.className = 'pokemon-stats-retro no-pokeballs';
            
            // Hide default actions and show no pokeballs options
            document.getElementById('defaultActions').classList.add('hidden');
            document.getElementById('noPokeballs').classList.remove('hidden');
        }

        // Start throw animation
        function startThrowAnimation() {
            if (!currentPokemonData) {
                alert('No Pokemon data available!');
                return;
            }
            
            // Set up throw screen
            document.getElementById('throwPokemonSprite').src = 
                currentPokemonData.sprites?.official_artwork || currentPokemonData.sprites?.front_default || '';
            
            // Set type-based header for throw modal
            const throwTypeHeader = document.getElementById('throwTypeHeader');
            if (currentPokemonData.types && currentPokemonData.types.length > 0) {
                const primaryType = currentPokemonData.types[0].type?.name || currentPokemonData.types[0];
                throwTypeHeader.className = `pokemon-type-header ${primaryType}`;
            } else {
                throwTypeHeader.className = 'pokemon-type-header normal';
            }
            
            showUIState(UI_STATES.THROW);
            
            // Initialize pokeball throw logic
            const pokeballElem = document.getElementById('pokeball');
            const targetElem = document.getElementById('throwPokemonSprite');
            
            // Use existing PokeballThrow class if available
            if (typeof PokeballThrow !== 'undefined') {
                new PokeballThrow({
                    pokeballElem,
                    targetElem,
                    onThrow: async function() {
                        await handleCatchPokemon();
                    }
                });
            } else {
                // Simple fallback - just catch on click
                pokeballElem.onclick = async function() {
                    await handleCatchPokemon();
                };
            }
        }

        // Handle running away
        function runAway() {
            console.log('üèÉ Player chose to run away');
            currentPokemonData = null;
            showUIState(UI_STATES.SCANNER);
        }

        // Handle catching Pokemon - Always succeeds when pokeball is thrown
        async function handleCatchPokemon() {
            if (!currentPokemonData) {
                alert('No Pokemon to catch!');
                return;
            }
            
            try {
                console.log(`üéØ Attempting to catch ${currentPokemonData.name}...`);
                
                // Show loading spinner while catching Pokemon
                showLoadingSpinner('Catching Pokemon...');
                
                // Use the catch service - either works or fails
                const result = await CatchPokemonService.catchPokemonOptimized(
                    currentPokemonData.id, 
                    window.currentUserData
                );
                
                hideLoadingSpinner();
                
                if (result.success) {
                    // Pokemon caught successfully
                    showCatchSuccessMessage(currentPokemonData.name);
                } else {
                    // Clear failure - no fallbacks
                    if (result.error.includes('No pokeballs available')) {
                        alert(`‚ùå No Pok√©balls available! Play the minigame to earn more.`);
                        showUIState(UI_STATES.ENCOUNTER);
                    } else {
                        alert(`‚ùå Failed to catch ${currentPokemonData.name}: ${result.error}`);
                        returnToScanner();
                    }
                }
                
            } catch (error) {
                hideLoadingSpinner();
                console.error('Catch error:', error);
                alert(`‚ùå Error catching Pokemon: ${error.message}`);
                returnToScanner();
            }
        }

        // Show catch success message and return to scanner
        async function showCatchSuccessMessage(pokemonName, isDemo = false) {
            const demoText = isDemo ? ' (Demo mode)' : '';
            
            // Get updated pokeball count to show in success message
            let pokeballInfo = '';
            if (!isDemo && typeof CatchPokemonService !== 'undefined') {
                try {
                    const currentUser = AuthService.getCurrentUser();
                    if (currentUser && currentUser.email) {
                        const remainingPokeballs = await CatchPokemonService.getUserPokeballCount(currentUser.email);
                        pokeballInfo = `<div style="margin-top: 15px; color: #ffcc02; font-size: 1rem;">
                            ‚öæ Pok√©balls remaining: ${remainingPokeballs}
                        </div>`;
                    }
                } catch (error) {
                    console.error('Error getting updated pokeball count:', error);
                }
            }
            
            // Create a nice success overlay
            const successOverlay = document.createElement('div');
            successOverlay.className = 'modal-overlay';
            successOverlay.style.background = 'rgba(0,0,0,0.8)';
            successOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üéâ</div>
                    <h2 style="color: #4CAF50; font-size: 2rem; margin-bottom: 15px;">
                        ${pokemonName} Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${pokemonName} has been added to your Pok√©dex${demoText}
                    </p>
                    ${pokeballInfo}
                    <button onclick="returnToMainMenu()" 
                            class="pokemon-btn pokemon-btn-success pokemon-btn-lg"
                            style="margin-top: 20px;">
                        Return to Main Menu
                    </button>
                </div>
            `;
            
            document.body.appendChild(successOverlay);
        }

        // Return to main menu and clean up
        function returnToMainMenu() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Redirect to main menu
            window.location.href = '/index.html';
        }

        // Navigate to home page
        function navigateHome() {
            // Stop any active scanning
            if (window.qrScanner) {
                qrScanner.stopScanning();
            }
            
            // Redirect to main menu
            window.location.href = '/index.html';
        }

        // Refresh QR Scanner
        function refreshQRScanner() {
            console.log('üîÑ Refreshing QR Scanner...');
            
            // Update button text and styling to show it's working
            const refreshBtn = document.getElementById('refreshScannerBtn');
            const originalText = refreshBtn.textContent;
            refreshBtn.textContent = '‚è≥ Refreshing...';
            refreshBtn.disabled = true;
            refreshBtn.className = 'pokemon-btn pokemon-btn-secondary'; // Change to secondary while loading
            
            // Stop current scanning
            if (window.qrScanner) {
                qrScanner.stopScanning();
            }
            
            // Clear any existing video streams
            const video = document.getElementById('qrVideo');
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
                video.srcObject = null;
            }
            
            // Reset debug info
            document.getElementById('videoDebugInfo').innerHTML = '';
            
            // Wait a moment then restart everything
            setTimeout(() => {
                // Reset button
                refreshBtn.textContent = originalText;
                refreshBtn.disabled = false;
                refreshBtn.className = 'pokemon-btn pokemon-btn-primary'; // Back to primary styling
                
                // Restart the camera and scanner
                if (window.qrScanner) {
                    // Reinitialize the camera
                    qrScanner.initCamera().then(() => {
                        console.log('‚úÖ QR Scanner refreshed successfully');
                        document.getElementById('videoDebugInfo').innerHTML = 
                            '<span style="color: var(--pokemon-green);">‚úÖ Scanner ready!</span>';
                        
                        // Clear the success message after 2 seconds
                        setTimeout(() => {
                            if (currentState === UI_STATES.SCANNER) {
                                document.getElementById('videoDebugInfo').innerHTML = '';
                            }
                        }, 2000);
                    }).catch(error => {
                        console.error('‚ùå Failed to refresh scanner:', error);
                        document.getElementById('videoDebugInfo').innerHTML = 
                            '<span style="color: var(--pokemon-red);">‚ùå Refresh failed</span>';
                        refreshBtn.className = 'pokemon-btn pokemon-btn-danger'; // Show error state
                    });
                }
            }, 500);
        }

        // Show duplicate Pokemon modal with nice UI
        function showDuplicatePokemonModal(pokemonNumber, message) {
            // Create a nice error overlay
            const errorOverlay = document.createElement('div');
            errorOverlay.className = 'modal-overlay';
            errorOverlay.style.background = 'rgba(0,0,0,0.8)';
            errorOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üîÑ</div>
                    <h2 style="color: #ff9800; font-size: 2rem; margin-bottom: 15px;">
                        Already Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${message}
                    </p>
                    <p style="font-size: 1rem; color: #ffcc02; margin-bottom: 30px;">
                        Try scanning a different Pok√©mon QR code to catch a new one!
                    </p>
                    <button onclick="closeDuplicateModal()" 
                            class="pokemon-btn pokemon-btn-primary"
                            style="margin-right: 10px;">
                        Continue Scanning
                    </button>
                    <button onclick="returnToMainMenu()" 
                            class="pokemon-btn pokemon-btn-secondary">
                        Main Menu
                    </button>
                </div>
            `;
            
            document.body.appendChild(errorOverlay);
            
            // Auto-close and return to scanner after 6 seconds if no action taken
            setTimeout(() => {
                if (document.body.contains(errorOverlay)) {
                    closeDuplicateModal();
                }
            }, 6000);
        }

        // Close duplicate modal and return to scanner
        function closeDuplicateModal() {
            // Remove the duplicate error overlay
            const errorOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            errorOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Return to scanner
            showUIState(UI_STATES.SCANNER);
        }

        // Return to scanner and clean up (for other cases like errors)
        function returnToScanner() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Reset and go back to scanner
            currentPokemonData = null;
            showUIState(UI_STATES.SCANNER);
        }

        // Minigame completion guard to prevent duplicates
        let isMinigameCatchInProgress = false;

        // Minigame completed - actually catch the Pokemon (no pokeball consumption)
        async function catchPokemonViaMinigame() {
            // Prevent multiple simultaneous calls that could create duplicates
            if (isMinigameCatchInProgress) {
                console.log('Minigame catch already in progress, ignoring duplicate call');
                return;
            }
            
            isMinigameCatchInProgress = true;
            
            try {
                const currentUser = AuthService.getCurrentUser();
                if (!currentUser || !currentUser.email) {
                    console.log('User not authenticated for minigame completion');
                    return;
                }

                console.log('Minigame completed successfully - catching Pokemon without consuming pokeballs');
                
                // Hide ALL UI elements immediately to prevent "No Pokeballs" screen from showing
                document.getElementById('noPokeballActions').classList.add('hidden');
                document.getElementById('encounterModal').classList.add('hidden');
                document.getElementById('throwModal').classList.add('hidden');
                
                // Show a loading message with rotating SVG pokeball while catching
                const loadingOverlay = document.createElement('div');
                loadingOverlay.id = 'minigameLoadingOverlay';
                loadingOverlay.className = 'modal-overlay';
                loadingOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100vw;
                    height: 100vh;
                    background: rgba(0,0,0,0.8);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 9999;
                `;
                loadingOverlay.innerHTML = `
                    <style>
                        @keyframes rotatePokeball {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                        .rotating-pokeball-svg {
                            width: 80px;
                            height: 80px;
                            animation: rotatePokeball 1.5s linear infinite;
                            margin-bottom: 20px;
                            filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));
                        }
                    </style>
                    <div style="text-align: center; color: white; padding: 40px;">
                        <svg class="rotating-pokeball-svg" width="80" height="80" viewBox="0 0 120 120" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <circle cx="60" cy="60" r="55" stroke="#222" stroke-width="5" fill="#fff"/>
                            <path d="M5 60a55 55 0 0 1 110 0" fill="#e53935" stroke="#222" stroke-width="5"/>
                            <circle cx="60" cy="60" r="20" stroke="#222" stroke-width="5" fill="#fff"/>
                            <circle cx="60" cy="60" r="10" fill="#eee" stroke="#222" stroke-width="3"/>
                        </svg>
                        <h2 style="color: #4CAF50; font-size: 1.5rem; margin: 0;">
                            Catching Pokemon...
                        </h2>
                    </div>
                `;
                document.body.appendChild(loadingOverlay);
                
                // Actually catch the Pokemon using the special minigame catch method
                const result = await CatchPokemonService.catchPokemonViaMinigame(
                    window.currentPokemonNumber, 
                    window.currentUserData
                );
                
                // Remove loading overlay
                const loadingEl = document.getElementById('minigameLoadingOverlay');
                if (loadingEl) {
                    document.body.removeChild(loadingEl);
                }
                
                if (result.success) {
                    console.log('Pokemon caught successfully via minigame:', result.pokemon.name);
                    console.time('Success message display time');
                    // Show the same success message as normal catch but with "Back to Menu" button
                    showMinigameSuccessMessage(result.pokemon.name);
                    console.timeEnd('Success message display time');
                    // Reset guard flag on success
                    isMinigameCatchInProgress = false;
                } else {
                    console.error('Minigame catch failed:', result.error);
                    alert(`Failed to catch Pokemon: ${result.error}`);
                    // Return to scanner on failure
                    window.currentPokemonNumber = null;
                    currentPokemonData = null;
                    setUIState(UI_STATES.SCANNER);
                    // Reset guard flag on failure
                    isMinigameCatchInProgress = false;
                }
                
            } catch (error) {
                console.error('Error completing minigame:', error);
                alert('Error completing minigame. Please try again.');
                // Remove loading overlay if it exists
                const loadingEl = document.getElementById('minigameLoadingOverlay');
                if (loadingEl) {
                    document.body.removeChild(loadingEl);
                }
                // Return to scanner on error
                window.currentPokemonNumber = null;
                currentPokemonData = null;
                setUIState(UI_STATES.SCANNER);
            } finally {
                // Always reset the guard flag to allow future minigame attempts
                isMinigameCatchInProgress = false;
            }
        }

        // Show minigame completion success message (same as catch success but different button)
        function showMinigameSuccessMessage(pokemonName) {
            console.log('Starting to create success overlay...');
            
            // Create a nice success overlay (same style as normal catch)
            const successOverlay = document.createElement('div');
            successOverlay.className = 'modal-overlay';
            successOverlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;
            
            successOverlay.innerHTML = `
                <div style="text-align: center; color: white; padding: 40px; background: rgba(0,0,0,0.9); border-radius: 20px; max-width: 90vw;">
                    <div style="font-size: 4rem; margin-bottom: 20px;">üéâ</div>
                    <h2 style="color: #4CAF50; font-size: 2rem; margin-bottom: 15px;">
                        ${pokemonName} Caught!
                    </h2>
                    <p style="font-size: 1.2rem; margin-bottom: 20px;">
                        ${pokemonName} has been added to your Pok√©dex
                    </p>
                    <button onclick="backToMenu()" 
                            style="background: linear-gradient(145deg, #4CAF50, #45a049); 
                                   color: white; padding: 15px 30px; border: none; 
                                   border-radius: 25px; font-size: 1.1rem; cursor: pointer;
                                   margin-top: 20px;">
                        Back to Menu
                    </button>
                </div>
            `;
            
            console.log('üéÆ About to append success overlay to DOM...');
            document.body.appendChild(successOverlay);
            console.log('üéÆ Success overlay added to DOM!');
        }

        // Back to menu function for minigame completion
        function backToMenu() {
            // Remove any success overlays
            const successOverlays = document.querySelectorAll('.modal-overlay:not(#encounterModal):not(#throwModal)');
            successOverlays.forEach(overlay => {
                if (document.body.contains(overlay)) {
                    document.body.removeChild(overlay);
                }
            });
            
            // Clear stored Pokemon data and go back to main menu
            window.currentPokemonNumber = null;
            currentPokemonData = null;
            
            // Navigate to main menu
            window.location.href = '/index.html';
        }

        // Load Pokemon data
        async function loadPokemonData(pokemonNumber) {
            try {
                document.getElementById('videoDebugInfo').textContent = 'Loading Pokemon data...';
                
                // Try to load from enhanced JSON file first
                const response = await fetch('/src/data/pokemon.json');
                
                if (response.ok) {
                    const pokemonData = await response.json();
                    const pokemon = pokemonData.find(p => p.id === pokemonNumber);
                    
                    if (pokemon) {
                        document.getElementById('videoDebugInfo').textContent = '';
                        return {
                            id: pokemon.id,
                            name: pokemon.name.charAt(0).toUpperCase() + pokemon.name.slice(1),
                            types: pokemon.types,
                            sprites: pokemon.sprites,
                            stats: pokemon.stats
                        };
                    }
                }
                
                // No fallback - if our service doesn't work, fail clearly
                throw new Error('Pokemon not found in our database');
                
            } catch (error) {
                console.error('Error loading Pokemon data:', error);
                document.getElementById('videoDebugInfo').textContent = 'Failed to load Pokemon data';
                throw error; // Don't return null, throw the error
            }
        }

        // QR Scanner Class
        class QRScanner {
            constructor() {
                this.video = document.getElementById('qrVideo');
                this.canvas = document.createElement('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.scanning = false;
                this.stream = null;
                this.animationId = null; // Track animation frame ID
                this.scannerId = null; // Unique scanner session ID
                this.lastQRTime = 0; // Timestamp of last QR detection
                
                console.log('[QRScanner] Initializing...');
                this.initializeScanner();
            }
            
            async initializeScanner() {
                try {
                    console.log('üîß Initializing QR scanner...');
                    
                    // Check authentication if AuthService exists
                    if (typeof AuthService !== 'undefined') {
                        console.log('üîë Restoring authentication...');
                        await AuthService.restoreAuthFromSession();
                        
                        if (!AuthService.isAuthenticated()) {
                            console.error('‚ùå Authentication failed');
                            document.getElementById('videoDebugInfo').innerHTML = 
                                '<span style="color: #ff6b6b;">‚ö†Ô∏è Authentication required. Please log in.</span>';
                            return;
                        }
                        console.log('‚úÖ Authentication restored successfully');
                    } else {
                        console.warn('‚ö†Ô∏è AuthService not available');
                    }
                    
                    console.log('‚úÖ Authentication OK, starting camera setup...');
                    await this.setupCamera();
                    console.log('‚úÖ Scanner initialization complete');
                    
                } catch (error) {
                    console.error('Scanner initialization error:', error);
                    document.getElementById('videoDebugInfo').innerHTML = 
                        `<span style="color: #ff6b6b;">‚ùå Scanner init failed: ${error.message}</span>`;
                }
            }
            
            async setupCamera() {
                try {
                    console.log('üé• Setting up camera...');
                    
                    // Check if getUserMedia is available
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        throw new Error('Camera not supported on this device');
                    }
                    
                    // Try multiple camera configurations for better mobile compatibility
                    let stream = null;
                    const constraints = [
                        // First try: Prefer back camera
                        { video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } } },
                        // Fallback: Any camera
                        { video: { width: { ideal: 640 }, height: { ideal: 480 } } },
                        // Last resort: Basic video
                        { video: true }
                    ];
                    
                    for (let i = 0; i < constraints.length; i++) {
                        try {
                            console.log(`üé• Trying camera constraint ${i + 1}:`, constraints[i]);
                            stream = await navigator.mediaDevices.getUserMedia(constraints[i]);
                            console.log(`‚úÖ Camera constraint ${i + 1} worked!`);
                            break;
                        } catch (err) {
                            console.log(`‚ùå Camera constraint ${i + 1} failed:`, err.message);
                            if (i === constraints.length - 1) {
                                throw err; // Re-throw the last error
                            }
                        }
                    }
                    
                    if (!stream) {
                        throw new Error('Could not access camera with any configuration');
                    }
                    
                    this.video.srcObject = stream;
                    this.stream = stream;
                    
                    // Wait for video to be ready with better mobile support
                    return new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Camera setup timeout'));
                        }, 10000); // 10 second timeout
                        
                        const onReady = () => {
                            clearTimeout(timeout);
                            console.log(`üìπ Video ready: ${this.video.videoWidth}x${this.video.videoHeight}`);
                            
                            this.canvas.width = this.video.videoWidth || 640;
                            this.canvas.height = this.video.videoHeight || 480;
                            
                            document.getElementById('videoDebugInfo').innerHTML = 
                                '<span style="color: #4ecdc4;">üì∑ Camera ready - Point at a Pok√©mon QR code</span>';
                            
                            // Start scanning after a small delay to ensure video is fully ready
                            setTimeout(() => {
                                this.startScanning();
                                resolve();
                            }, 500);
                        };
                        
                        if (this.video.readyState >= 2) {
                            onReady();
                        } else {
                            this.video.addEventListener('loadedmetadata', onReady, { once: true });
                            this.video.addEventListener('canplay', onReady, { once: true });
                        }
                    });
                        
                } catch (error) {
                    console.error('Camera setup error:', error);
                    document.getElementById('videoDebugInfo').innerHTML = 
                        `<span style="color: #ff6b6b;">‚ùå Camera error: ${error.message}</span>`;
                    throw error;
                }
            }
            
            startScanning() {
                if (this.scanning) return;
                
                this.scanning = true;
                this.scannerId = Date.now(); // Create unique session ID
                console.log('üéØ Starting QR scan loop... Session ID:', this.scannerId);
                // Remove automatic "Scanning for QR codes..." text - user now has refresh button
                    
                this.scanLoop();
            }
            
            stopScanning() {
                this.scanning = false;
                this.scannerId = null; // Invalidate session
                console.log('‚èπÔ∏è Stopping QR scanner - Session invalidated');
                
                // Cancel any pending animation frame
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                    console.log('üõë Cancelled pending animation frame');
                }
                
                if (this.stream) {
                    this.stream.getTracks().forEach(track => track.stop());
                }
            }
            
            scanLoop() {
                // STRONG SESSION VALIDATION - multiple checks to ensure we should continue
                const currentSessionId = this.scannerId;
                
                // Check 1: Basic scanning state
                if (!this.scanning) {
                    console.log('üõë Scan loop terminated - scanning=false');
                    this.animationId = null;
                    return;
                }
                
                // Check 2: Session validity
                if (!currentSessionId || this.scannerId !== currentSessionId) {
                    console.log('üõë Scan loop terminated - session invalid');
                    this.animationId = null;
                    return;
                }
                
                // Check 3: Video availability
                if (!this.video) {
                    console.log('üõë Scan loop terminated - no video');
                    this.animationId = null;
                    return;
                }
                
                // Check 4: Video readiness with mobile-friendly checks
                if (this.video.readyState === this.video.HAVE_ENOUGH_DATA && 
                    this.video.videoWidth > 0 && this.video.videoHeight > 0) {
                    
                    try {
                        // Update canvas size if video dimensions changed (mobile rotation)
                        if (this.canvas.width !== this.video.videoWidth || this.canvas.height !== this.video.videoHeight) {
                            this.canvas.width = this.video.videoWidth;
                            this.canvas.height = this.video.videoHeight;
                            console.log(`üìπ Canvas resized to ${this.canvas.width}x${this.canvas.height}`);
                        }
                        
                        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
                        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                        
                        // Scan for QR code using jsQR
                        if (typeof jsQR !== 'undefined') {
                            const code = jsQR(imageData.data, imageData.width, imageData.height);
                            
                            if (code) {
                                console.log('üéØ QR Code detected:', code.data);
                                this.handleQRCode(code.data);
                                return; // Stop scanning after successful detection
                            }
                        }
                    } catch (error) {
                        console.error('Error in scan loop:', error);
                        // Continue scanning despite errors
                    }
                }
                
                // FINAL CHECK before scheduling next frame - triple validation
                if (this.scanning && this.scannerId === currentSessionId && currentSessionId !== null) {
                    // Use setTimeout for mobile compatibility (more predictable than requestAnimationFrame on mobile)
                    this.animationId = requestAnimationFrame(() => this.scanLoop());
                } else {
                    console.log('üõë Final check failed - stopping scan loop');
                    this.animationId = null;
                }
            }
            
            handleQRCode(data) {
                // IMMEDIATE COMPLETE STOP - no more frames should execute
                this.scanning = false;
                const oldSessionId = this.scannerId;
                this.scannerId = null; // Invalidate session immediately
                
                // Cancel any pending animation frame immediately
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
                
                console.log(`üõë QR scanner COMPLETELY STOPPED - Session ${oldSessionId} invalidated`);
                
                // Add timestamp to prevent rapid duplicate processing
                const now = Date.now();
                if (this.lastQRTime && (now - this.lastQRTime) < 2000) {
                    console.log('üö´ QR detected too soon after last one, ignoring');
                    return;
                }
                this.lastQRTime = now;
                
                // Extract Pokemon number from QR data
                const pokemonNumber = this.extractPokemonNumber(data);
                
                if (pokemonNumber && pokemonNumber > 0 && pokemonNumber <= 1010) { // Valid Pokemon range
                    console.log('‚úÖ Valid Pokemon QR detected, processing...');
                    // Call immediately without delay to prevent any more scan loops
                    onQRCodeDetected(pokemonNumber, data);
                } else {
                    console.log('‚ùå Invalid Pokemon QR code, will resume scanning');
                    document.getElementById('videoDebugInfo').innerHTML = 
                        '<span style="color: #ff6b6b;">‚ùå Invalid Pok√©mon QR code</span>';
                    
                    // Resume scanning after 2 seconds for invalid codes
                    setTimeout(() => {
                        if (currentState === UI_STATES.SCANNER && !this.scanning) {
                            // Clear the error message, but don't show "scanning" text - user has refresh button
                            document.getElementById('videoDebugInfo').innerHTML = '';
                            this.startScanning(); // Use startScanning to create new session
                        }
                    }, 2000);
                }
            }
            
            extractPokemonNumber(data) {
                // Handle various QR code formats
                console.log('Parsing QR data:', data);
                
                // Direct number
                if (/^\d+$/.test(data)) {
                    return parseInt(data);
                }
                
                // Pokemon:123 format
                if (data.toLowerCase().includes('pokemon')) {
                    const match = data.match(/pokemon[:\s]*(\d+)/i);
                    if (match) return parseInt(match[1]);
                }
                
                // Extract any number from the string
                const numberMatch = data.match(/(\d+)/);
                if (numberMatch) {
                    return parseInt(numberMatch[1]);
                }
                
                return null;
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Pokemon Scanner - DOM Content Loaded');
            
            // Wait a bit for all scripts to load
            setTimeout(() => {
                console.log('Pokemon Scanner - Starting initialization...');
                
                // Check if required services are loaded
                if (typeof AuthService === 'undefined') {
                    console.error('‚ùå AuthService not loaded');
                    document.getElementById('videoDebugInfo').innerHTML = 
                        '<span style="color: #ff6b6b;">‚ùå Authentication service not loaded</span>';
                    return;
                }
                
                if (typeof CatchPokemonService === 'undefined') {
                    console.error('‚ùå CatchPokemonService not loaded');
                    document.getElementById('videoDebugInfo').innerHTML = 
                        '<span style="color: #ff6b6b;">‚ùå Pokemon service not loaded</span>';
                    return;
                }
                
                console.log('‚úÖ All services loaded successfully');
                
                // Show scanner UI initially
                showUIState(UI_STATES.SCANNER);
                
                // Initialize QR scanner
                qrScanner = new QRScanner();
            }, 500); // Give scripts time to load
        });
    </script>
</body>
</html>
